<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在安装完一个新的Ubuntu后，我是这样设置的</title>
      <link href="/2020/07/29/ubuntuset/"/>
      <url>/2020/07/29/ubuntuset/</url>
      
        <content type="html"><![CDATA[<h2 id="在安装完一个新的Ubuntu后，我是怎么设置的"><a href="#在安装完一个新的Ubuntu后，我是怎么设置的" class="headerlink" title="在安装完一个新的Ubuntu后，我是怎么设置的"></a>在安装完一个新的<em>Ubuntu</em>后，我是怎么设置的</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>每次安装一个新的Ubuntu的我都要大费周章，尤其是输入法，theme，icon 巴拉巴拉之类的，叫老夫实在是有点烦，这次都记下来，为下次节约时间！！！！<br>奥利给！</p></blockquote><blockquote><blockquote><p>ps：　deepin　刻录工具　Is the best</p></blockquote></blockquote><h3 id="1-chrome-浏览器"><a href="#1-chrome-浏览器" class="headerlink" title="1.chrome 浏览器"></a>1.chrome 浏览器</h3><p>google chrome 直接从官网下载</p><h3 id="2-VIM-以防需要改写文件"><a href="#2-VIM-以防需要改写文件" class="headerlink" title="2.VIM(以防需要改写文件)"></a>2.VIM(以防需要改写文件)</h3><p><code>sudo apt install vim</code></p><h3 id="3-搜狗输入法（搜狗输入法的使用体验还是及其良好的）"><a href="#3-搜狗输入法（搜狗输入法的使用体验还是及其良好的）" class="headerlink" title="3.搜狗输入法（搜狗输入法的使用体验还是及其良好的）"></a>3.搜狗输入法（搜狗输入法的使用体验还是及其良好的）</h3><blockquote><p>卸载 ibus:<code>sudo apt-get remove ibus</code></p></blockquote><hr><blockquote><p>清除ibus配置:<code>sudo apt-get purge ibus</code></p><hr><p>安装fcitx输入法框架:<code>sudo apt install fcitx-table-wbpy fcitx-config-gtk</code></p></blockquote><hr><p>打开fcitx,配置fcitx输入法</p><hr><p>logout</p><hr><p>下载搜狗输入法：<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="noopener">搜狗输入法官网</a></p><hr><p>下载.deb并安装</p><hr><p>打开Fcitx进行配置，将搜狗输入法加入</p><blockquote><blockquote><p>注意，切勿将搜狗输入法放在第一个，否则可能会出现乱码；比较好的设置是１号English()，２号搜狗，无缝切换，丝般顺滑。</p></blockquote></blockquote><h3 id="4-重头戏来了，主题设置！"><a href="#4-重头戏来了，主题设置！" class="headerlink" title="4.重头戏来了，主题设置！"></a>4.重头戏来了，主题设置！</h3><blockquote><p>应该没人能忍受ubuntu最初难看的橙色主题。所以有必要为自己的身心健康创造良好的环境。</p></blockquote><blockquote><p>ubuntu桌面主题的多样化都要归功于一个史诗级应用：ｔｗｅａｋｓ*</p></blockquote><ul><li>所以，第一步必然：<code>sudo apt install gnome-tweak-tool</code></li></ul><blockquote><p>安装完成之后，就可以到这个<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">神奇的网站</a>下载你所需要的所有theme,icon,curse，wallpaper;等等文件，然后放在相应位置即可</p></blockquote><ol><li>主题存放目录：<code>/usr/share/themes</code> 或 <code>~/.themes</code></li><li>图标和鼠标存放目录：<code>/usr/share/icons</code> 或<code>~/.icons</code>（鼠标文件夹会多个文件）</li><li>字体存放目录：<code>/usr/share/fonts</code>或 <code>~/.fonts</code></li></ol><blockquote><p>管理员权限操作</p><p>然后就可以有一个美美的心情咯</p></blockquote><h3 id="5-Dash-To-Dock"><a href="#5-Dash-To-Dock" class="headerlink" title="5.Dash To Dock"></a>5.Dash To Dock</h3><blockquote><p>这个Dock插件提供了很多选项定制</p></blockquote><ul><li>到<a href="https://extensions.gnome.org/extension/307/dash-to-dock/" target="_blank" rel="noopener">gnome网站</a>弹出紫色链接，然后CLICK TO INSTALL.</li></ul><h3 id="6-备份工具"><a href="#6-备份工具" class="headerlink" title="6.备份工具"></a>6.备份工具</h3><ul><li>How to Backup Ubuntu Files and Folders</li></ul><blockquote><p>工具：<a href="https://snapcraft.io/deja-dup" target="_blank" rel="noopener">Déjà Dup Backup Tool</a></p></blockquote><p><code>sudo snap install deja-dup --classic</code>安装或者在APP STORE里搜索下载。</p><h3 id="7-右键新建文件"><a href="#7-右键新建文件" class="headerlink" title="7.右键新建文件"></a>7.右键新建文件</h3><ul><li>windows 熟悉的右键新建文件实在是太习惯了，而 ubuntu 下却没有，没有问题可以难道我！怎么实现呢？</li></ul><blockquote><p>新建一个你要右键新建类型文件，放入当前登陆用户的”Templates”目录中，随后你再鼠标右键，就会有你想要的新建文件类型了！<br>easy!</p></blockquote><h3 id="8-pip安装"><a href="#8-pip安装" class="headerlink" title="8.pip安装"></a>8.pip安装</h3><ul><li>Pip is a package management system that simplifies installation and management of software packages written in Python such as those found in the Python Package Index (PyPI).</li></ul><p><code>sudo apt install python3-pip</code></p><h3 id="9-How-To-Install-KDE-Connect"><a href="#9-How-To-Install-KDE-Connect" class="headerlink" title="9.How To Install KDE Connect"></a>9.How To Install KDE Connect</h3><ul><li><p>Thankfully there’s a PPA available to install KDE Connect from. To add it to your Software Sources in Ubuntu:</p></li><li><p><code>sudo add-apt-repository ppa:webupd8team/indicator-kdeconnect</code></p></li><li><p>Now proceed to install KDE Connect (and the latest stable release of indicator-kdeconnect) by running this command:</p></li><li><p><code>sudo apt update &amp;&amp; sudo apt install kdeconnect indicator-kdeconnect</code></p></li></ul><h3 id="9-Ghost-Writer"><a href="#9-Ghost-Writer" class="headerlink" title="9.Ghost Writer"></a>9.Ghost Writer</h3><pre><code>sudo add-apt-repository ppa:wereturtle/ppasudo apt-get updatesudo apt-get install ghostwriter</code></pre><h3 id="8-VLC播放器（最好用的视频播放器，没有之一）"><a href="#8-VLC播放器（最好用的视频播放器，没有之一）" class="headerlink" title="8.VLC播放器（最好用的视频播放器，没有之一）"></a>8.VLC播放器（最好用的视频播放器，没有之一）</h3><ul><li><code>sudo snap install vlc</code></li></ul><h3 id="9-（号外）壁纸网站"><a href="#9-（号外）壁纸网站" class="headerlink" title="9.（号外）壁纸网站"></a>9.（号外）壁纸网站</h3><ul><li><a href="https://wallpapershome.com" target="_blank" rel="noopener">https://wallpapershome.com</a></li><li><a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">https://alpha.wallhaven.cc/</a></li></ul><ul><li><a href="https://pixabay.com" target="_blank" rel="noopener">https://pixabay.com</a></li></ul><hr><p>参考作者网站：<a href="https://www.jianshu.com/p/7d153a484f72" target="_blank" rel="noopener">https://www.jianshu.com/p/7d153a484f72</a></p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu科学上网（ultimite）</title>
      <link href="/2020/07/29/setssr/"/>
      <url>/2020/07/29/setssr/</url>
      
        <content type="html"><![CDATA[<h3 id="ubuntu科学上网（ultimite）"><a href="#ubuntu科学上网（ultimite）" class="headerlink" title="ubuntu科学上网（ultimite）"></a>ubuntu科学上网（ultimite）</h3><hr><blockquote><p>思路：</p><blockquote><ol><li>在ubuntu安装SSR代理</li><li>ubuntu系统设置代理从本机端口映射到代理服务器</li></ol></blockquote></blockquote><h4 id="代理设置方法"><a href="#代理设置方法" class="headerlink" title="代理设置方法"></a>代理设置方法</h4><h4 id="1-写脚本安装SSR客户端-参考Charles-Xu的作品"><a href="#1-写脚本安装SSR客户端-参考Charles-Xu的作品" class="headerlink" title="1. 写脚本安装SSR客户端(参考Charles Xu的作品)"></a>1. 写脚本安装SSR客户端(参考Charles Xu的<a href="https://github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr" target="_blank" rel="noopener">作品</a>)</h4><ul><li><code>cd /usr/local/bin</code>进入目录</li><li><code>sodu vim ssr.sh</code>新建脚本文件</li><li>复制大佬许的脚本，保存退出</li><li><code>chmod 775 ssr.sh</code>修改为可执行权限</li><li>如果此时运行，会缺少依赖，所以安装</li></ul><blockquote><p><code>sudo apt install python</code><br><code>sudo apt install jq</code><br><code>sudo apt install curl</code><br><code>sudo apt install proxychains4</code></p></blockquote><ul><li>安装完成后，运行<code>./ssr.sh test</code>若没错，则配置SSR</li><li><code>./ssr.sh config</code>填写代理服务器相关Jason文件信息，保存退出</li><li><code>./ssr.sh strat</code>代理服务打开</li></ul><h4 id="2-配置ubuntu系统代理"><a href="#2-配置ubuntu系统代理" class="headerlink" title="2. 配置ubuntu系统代理"></a>2. 配置ubuntu系统代理</h4><ul><li>打开 setting &gt; network &gt; network proxy</li><li>设置为 Maunal ，将 sockets hosts 设置为127.0.0.1 ,端口1080</li></ul><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h4><ul><li>因为 <code>/usr/local/bin</code> 本身就在系统变量中（<code>echo $PATH</code> 查看,在 ~/.bashrc 文件中修改，一般直接加在最后一行）所以直接在 terminal 中输入 <code>ssr.sh start</code> 即可。 </li></ul><hr><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><hr><blockquote><p>衷心感谢共享账号的好哥哥们！<br><a href="https://github.com/bannedbook/fanqiang" target="_blank" rel="noopener">https://github.com/bannedbook/fanqiang</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 记录 </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSR </tag>
            
            <tag> 科学上网 </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-means的安全性证明</title>
      <link href="/2020/07/29/kmeans/"/>
      <url>/2020/07/29/kmeans/</url>
      
        <content type="html"><![CDATA[<h2 id="K-means的安全性证明过程"><a href="#K-means的安全性证明过程" class="headerlink" title="K-means的安全性证明过程"></a>K-means的安全性证明过程</h2><h3 id="理想模型"><a href="#理想模型" class="headerlink" title="理想模型"></a>理想模型</h3><ul><li>在该模型中存在一个可信第三方,各参与方只需将数据提交给可信方,由它完成函数需要的所有计算,最终将计算结果相应地分发给各个参与方即可。理想模型中存在攻击者 S 试图通过控制的损坏方攻击理想协议以获取诚实方的数据。</li></ul><blockquote><p>参与者：C1,C2,…,Cm , S　其中 C1-Cm 为 m 个计算的参与方，S为可信第三方（完全可信的中心服务器）</p><p>上传数据：C1-Cm 将基因数据集 Ｘ1-Xm 上传到可信服务器Ｓ</p><p>计算：Ｓ计算Ｆ(X1,X2,…,Xm),其中Ｆ表示K-means聚类的方法。同时，Ｓ将计算结果发送给C1,C2,…,Cm</p></blockquote><hr><h3 id="理想协议的攻击者"><a href="#理想协议的攻击者" class="headerlink" title="理想协议的攻击者"></a>理想协议的攻击者</h3><ul><li>模拟器(又称为理想协议的攻击者)从理想协议中看到的信息,可以完全扮演真实协议,使得真实协议的攻击者以为就该模拟器就是真实协议。所以,假设攻击者的优势是不可忽略的,进而模拟器(理想协议的攻击者)能够以不可忽略的优势攻击理想协议。显然,理想协议是安全的,上述假设不成立,即,真实协议不存在攻击者。</li><li>我们定义一个模拟器S，它模拟理想世界中的攻击者。S将损坏的客户端的输入数据提交给该功能，并接收K-means聚类的最终输出值。</li></ul><hr><h3 id="现实模型"><a href="#现实模型" class="headerlink" title="现实模型"></a>现实模型</h3><ul><li>在该模型中不存在可信第三方,理想协议的敌手 S 利用已有知识模拟真实协议 π 的执行(所以又称为模拟器S)。具体地,在我们的模型中，可接受的对手可以破坏客户端的任何子集。鉴于该协议相对于客户端是对称的，我们只需要考虑以下情况：对手破坏了除一个客户端以外的所有C1,C2,…,Cm-1 ,最终使得该协议输出等于真实输出 sum,敌手 A 无法分辨模拟器和真实协议。</li></ul><hr><h3 id="真实协议的攻击者"><a href="#真实协议的攻击者" class="headerlink" title="真实协议的攻击者"></a>真实协议的攻击者</h3><ul><li>真实协议的攻击者不仅能入侵一方获得其输入和输出，还能够通过协议交互获得更多的额外信息</li></ul><hr><h3 id="真实协议的安全性"><a href="#真实协议的安全性" class="headerlink" title="真实协议的安全性"></a>真实协议的安全性</h3><ul><li><strong>真实协议π：</strong>采用代数电路和布尔电路执行函数</li><li><strong>参数：</strong>执行函数F,　安全参数λ</li><li><strong>安全性证明：</strong></li></ul><blockquote><p>因为该协议相对于客户端是对称的，所以我们是需要考虑一种最坏情况，即除了Cm,其他客户端都被对手破坏</p></blockquote><ul><li>理想协议攻击者入侵Ａ，真实协议的攻击者收到的信息为：</li></ul><ol><li>从OT(不经意传输协议)中收到的信息，因为该协议是安全的，所以没有获得任何信息优势。</li><li>最终计算结果和理想协议攻击者Ｓ完全一致，也没有获得额外的任何信息优势</li></ol><h5 id="攻击者-A-无法分辨真实协议执行与模拟器-S-模拟的协议执行。又因为模拟器-S-攻击理想协议的优势可忽略。因此所采用的协议是安全的，等价于理想协议。即：协议的参与方在输出与自己输入推测出的信息之外，不再获得其他额外有价值的信息。"><a href="#攻击者-A-无法分辨真实协议执行与模拟器-S-模拟的协议执行。又因为模拟器-S-攻击理想协议的优势可忽略。因此所采用的协议是安全的，等价于理想协议。即：协议的参与方在输出与自己输入推测出的信息之外，不再获得其他额外有价值的信息。" class="headerlink" title="攻击者 A 无法分辨真实协议执行与模拟器 S 模拟的协议执行。又因为模拟器 S 攻击理想协议的优势可忽略。因此所采用的协议是安全的，等价于理想协议。即：协议的参与方在输出与自己输入推测出的信息之外，不再获得其他额外有价值的信息。"></a>攻击者 A 无法分辨真实协议执行与模拟器 S 模拟的协议执行。又因为模拟器 S 攻击理想协议的优势可忽略。因此所采用的协议是安全的，等价于理想协议。即：协议的参与方在输出与自己输入推测出的信息之外，不再获得其他额外有价值的信息。</h5>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 证明 </category>
          
          <category> 隐私保护 </category>
          
          <category> Privacy-preserving </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐私保护 </tag>
            
            <tag> Privacy Preserving </tag>
            
            <tag> K-means </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> machine learning </tag>
            
            <tag> classify </tag>
            
            <tag> 分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA JIT</title>
      <link href="/2020/07/29/jit-in-java/"/>
      <url>/2020/07/29/jit-in-java/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-JIT-笔记"><a href="#JAVA-JIT-笔记" class="headerlink" title="JAVA JIT 笔记"></a>JAVA JIT 笔记</h1><hr><h3 id="JIT-in-JRE"><a href="#JIT-in-JRE" class="headerlink" title="JIT in JRE"></a>JIT in JRE</h3><ul><li><strong>what is JIT ?</strong></li></ul><p>The Just-In-Time (JIT) compiler is a component of the Java Runtime Environment that <strong>improves the performance</strong> of Java applications at run time. Nothing in the JVM affects performance more than the compiler, and choosing a compiler is one of the first decisions made when running a Java application—whether you are a Java developer or an end-user.</p><hr><p>（JIT）编译器是Java运行时环境的一个组件，可提高运行时Java应用程序的性能。 JVM中没有什么比编译器更能影响性能，而选择编译器是运行Java应用程序时做出的首要决定之一，无论您是Java开发人员还是最终用户。</p><hr><ul><li><strong>An Overview</strong></li></ul><p>The key of java power “Write once, run everywhere” is <code>bytecode</code>. The way bytecodes get converted to the appropriate native instructions for an application has a huge impact on the speed of an application. These bytecode can be interpreted, compiled to native code or directly executed on a processor whose Instruction Set Architecture is the bytecode specification.</p><hr><p>Java功能“写一次，到处运行”的关键是<code>bytecode</code>。 将字节码转换为适用于应用程序的适当本机指令的方式对应用程序的速度有很大的影响。 这些字节码可以被解释，编译为本地代码，或者直接在指令集体系结构为字节码规范的处理器上执行。</p><hr><p>Interpreting the bytecode which is the standard implementation of the Java Virtual Machine (JVM) makes execution of programs slow. To improve performance, JIT compilers interact with the JVM at run time and compile appropriate bytecode sequences into native machine code. When using a JIT compiler, the hardware can execute the native code, as opposed to having the JVM interpret the same sequence of bytecode repeatedly and incurring the penalty of a relatively lengthy translation process. This can lead to performance gains in the execution speed, unless methods are executed less frequently. The time that a JIT compiler takes to compile the bytecode is added to the overall execution time, and could lead to a higher execution time than an interpreter for executing the bytecode if the methods that are compiled by the JIT are not invoked frequently.</p><hr><p>解释字节码是Java虚拟机（JVM）的标准实现，这会使程序的执行速度变慢。 为了提高性能，JIT编译器在运行时与JVM交互，并将适当的字节码序列编译为本地机器代码。 当使用JIT编译器时，硬件可以执行本机代码，而不是让JVM重复解释相同的字节码序列，并导致翻译过程相对冗长。 除非方法的执行频率降低，否则这可能会导致执行速度提高。 JIT编译器编译字节码所花费的时间被添加到总体执行时间中，并且如果不频繁调用JIT编译的方法，则可能导致比用于执行字节码的解释器更长的执行时间。</p><hr><p>The JIT compiler performs certain optimizations when compiling the bytecode to native code. Since the JIT compiler translates a series of bytecode into native instructions, it can perform some simple optimizations. Some of the common optimizations performed by JIT compilers are data-analysis, translation from stack operations to register operations, reduction of memory accesses by register allocation, elimination of common sub-expressions etc. The higher the degree of optimization done by a JIT compiler, the more time it spends in the execution stage. Therefore a JIT compiler cannot afford to do all the optimizations that is done by a static compiler, both because of the overhead added to the execution time and because it has only a restricted view of the program.</p><hr><p>当将字节码编译为本地代码时，JIT编译器会执行某些优化。 由于JIT编译器将一系列字节码转换为本机指令，因此它可以执行一些简单的优化。 JIT编译器执行的一些常见优化操作包括数据分析，从堆栈操作到寄存器操作的转换，通过寄存器分配减少内存访问，消除公共子表达式等。JIT编译器进行的优化程度越高， 在执行阶段花费的时间越多。 因此，JIT编译器无法承担所有静态编译器所做的优化，这不仅是因为增加了执行时间的开销，而且还因为它只对程序进行了限制。</p><hr><ul><li><strong>How does it work ?!</strong></li></ul><p>The Just-In-Time (JIT) compiler is a component of the Java Runtime Environment that improves the performance of Java applications at run time. Java programs consists of classes, which contain platform neutral bytecode that can be interpreted by a JVM on many different computer architectures. At run time, the JVM loads the class files, determines the semantics of each individual bytecode, and performs the appropriate computation. The additional processor and memory usage during interpretation means that a Java application performs more slowly than a native application. The JIT compiler helps improve the performance of Java programs by compiling bytecode into native machine code at run time.</p><p><img src="https://imgkr.cn-bj.ufileos.com/37946e31-ec07-4fb9-94c2-d8e9dcdcfd59.png" alt="JIT"></p><hr><p>（JIT）编译器是Java运行时环境的一个组件，可提高运行时Java应用程序的性能。 Java程序由类组成，这些类包含平台中立的字节码，可以由JVM在许多不同的计算机体系结构上解释。 在运行时，JVM加载类文件，确定每个单个字节码的语义，并执行适当的计算。 解释过程中额外的处理器和内存使用情况意味着Java应用程序比本地应用程序执行得更慢。 JIT编译器通过在运行时将字节码编译为本机机器代码来帮助提高Java程序的性能。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> JAVA </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 工作原理</title>
      <link href="/2020/07/29/springmvc/"/>
      <url>/2020/07/29/springmvc/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringMVC-工作原理（重要）"><a href="#SpringMVC-工作原理（重要）" class="headerlink" title="SpringMVC 工作原理（重要）"></a>SpringMVC 工作原理（重要）</h3><p><strong>简单来说：</strong></p><p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Moder）-&gt;将得到视图对象返回给用户</p><p><strong>如下图所示：</strong></p><p><img src="https://i0.hdslb.com/bfs/album/aa5311b240c042132db43fd8ad7c9fd5e2684e44.png@1e_1c.webp" alt></p><p><strong>流程说明（重要）：</strong></p><p>（1）客户端（浏览器）发送请求，直接请求到 DispatcherServlet。</p><p>（2）DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。</p><p>（3）解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。</p><p>（4）HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p><p>（5）处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。</p><p>（6）ViewResolver 会根据逻辑 View 查找实际的 View。</p><p>（7）DispaterServlet 把返回的 Model 传给 View（视图渲染）。</p><p>（8）把 View 返回给请求者（浏览器）</p><h3 id="SpringMVC-重要组件说明"><a href="#SpringMVC-重要组件说明" class="headerlink" title="SpringMVC 重要组件说明"></a>SpringMVC 重要组件说明</h3><p><strong>1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供（重要）</strong></p><p>作用：<strong>Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。</strong></p><p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong></p><p>作用：根据请求的url查找Handler。HandlerMapping负责根据用户请求找到Handler即处理器（Controller），SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p><strong>3、处理器适配器HandlerAdapter</strong></p><p>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><p><strong>4、处理器Handler(需要工程师开发)</strong></p><p>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p><p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong></p><p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p><p><strong>6、视图View(需要工程师开发)</strong></p><p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p><p><strong>注意：处理器Handler（也就是我们平常说的Controller控制器）以及视图层view都是需要我们自己手动开发的。其他的一些组件比如：前端控制器DispatcherServlet、处理器映射器HandlerMapping、处理器适配器HandlerAdapter等等都是框架提供给我们的，不需要自己手动开发。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/2020/06/23/mybatisplus-codegenerator/"/>
      <url>/2020/06/23/mybatisplus-codegenerator/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h2><blockquote><p> <strong>CodeGenerator</strong></p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>DbType<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>IdType<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>AutoGenerator<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span>DataSourceConfig<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span>GlobalConfig<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span>PackageConfig<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span>StrategyConfig<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span>rules<span class="token punctuation">.</span>DateType<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span>rules<span class="token punctuation">.</span>NamingStrategy<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author * @since 2018/12/13 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CodeGenerator</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1、创建代码生成器</span>        AutoGenerator mpg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2、全局配置</span>        GlobalConfig gc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GlobalConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String projectPath <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user.dir"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setOutputDir</span><span class="token punctuation">(</span>projectPath <span class="token operator">+</span> <span class="token string">"/src/main/java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setAuthor</span><span class="token punctuation">(</span><span class="token string">"testjava"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setOpen</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//生成后是否打开资源管理器</span>        gc<span class="token punctuation">.</span><span class="token function">setFileOverride</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//重新生成时文件是否覆盖</span>        gc<span class="token punctuation">.</span><span class="token function">setServiceName</span><span class="token punctuation">(</span><span class="token string">"%sService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//去掉Service接口的首字母I</span>        gc<span class="token punctuation">.</span><span class="token function">setIdType</span><span class="token punctuation">(</span>IdType<span class="token punctuation">.</span>ID_WORKER<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//主键策略</span>        gc<span class="token punctuation">.</span><span class="token function">setDateType</span><span class="token punctuation">(</span>DateType<span class="token punctuation">.</span>ONLY_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义生成的实体类中日期类型</span>        gc<span class="token punctuation">.</span><span class="token function">setSwagger2</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启Swagger2模式</span>        mpg<span class="token punctuation">.</span><span class="token function">setGlobalConfig</span><span class="token punctuation">(</span>gc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3、数据源配置</span>        DataSourceConfig dsc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/guli"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setDriverName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setDbType</span><span class="token punctuation">(</span>DbType<span class="token punctuation">.</span>MYSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>        mpg<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dsc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4、包配置</span>        PackageConfig pc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PackageConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setModuleName</span><span class="token punctuation">(</span><span class="token string">"edu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//模块名</span>        pc<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span><span class="token string">"com.example.demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setController</span><span class="token punctuation">(</span><span class="token string">"controller"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token string">"entity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setService</span><span class="token punctuation">(</span><span class="token string">"service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setMapper</span><span class="token punctuation">(</span><span class="token string">"mapper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mpg<span class="token punctuation">.</span><span class="token function">setPackageInfo</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 5、策略配置</span>        StrategyConfig strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StrategyConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strategy<span class="token punctuation">.</span><span class="token function">setInclude</span><span class="token punctuation">(</span><span class="token string">"edu_teacher"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strategy<span class="token punctuation">.</span><span class="token function">setNaming</span><span class="token punctuation">(</span>NamingStrategy<span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据库表映射到实体的命名策略</span>        strategy<span class="token punctuation">.</span><span class="token function">setTablePrefix</span><span class="token punctuation">(</span>pc<span class="token punctuation">.</span><span class="token function">getModuleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//生成实体时去掉表前缀</span>        strategy<span class="token punctuation">.</span><span class="token function">setColumnNaming</span><span class="token punctuation">(</span>NamingStrategy<span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据库表字段映射到实体的命名策略</span>        strategy<span class="token punctuation">.</span><span class="token function">setEntityLombokModel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lombok 模型 @Accessors(chain = true) setter链式操作</span>        strategy<span class="token punctuation">.</span><span class="token function">setRestControllerStyle</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//restful api风格控制器</span>        strategy<span class="token punctuation">.</span><span class="token function">setControllerMappingHyphenStyle</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//url中驼峰转连字符</span>        mpg<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 6、执行</span>        mpg<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>controller———&gt;mapper———-&gt;service</p><p>mapper———-&gt;service过程mbp已经完成</p><p>所以只需要写contoller———&gt;mapper</p><p>localhost:8001/eduservice/teacher/findAll</p><p>get 可以用浏览器进行测试</p><p>但是post/delete/…不行，所以用工具：swagger  /   postman</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
            <tag> 项目 </tag>
            
            <tag> MybatisPlus </tag>
            
            <tag> Java </tag>
            
            <tag> 代码生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2020/05/23/springsecurity/"/>
      <url>/2020/05/23/springsecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="1-框架介绍"><a href="#1-框架介绍" class="headerlink" title="1.框架介绍"></a><strong>1.框架介绍</strong></h2><p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括<strong>用户认证（</strong>Authentication）和<strong>用户授权</strong>（Authorization）两个部分。</p><p>（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</p><p>（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><blockquote><p><strong>Spring Security其实就是用filter，多请求的路径进行过滤。</strong></p></blockquote><p>（1）如果是基于Session，那么Spring-security会对cookie里的sessionid进行解析，找到服务器存储的sesion信息，然后判断当前用户是否符合请求的要求。</p><p>（2）如果是token，则是解析出token，然后将当前请求加入到Spring-security管理的权限信息中去</p><h2 id="2、认证与授权实现思路"><a href="#2、认证与授权实现思路" class="headerlink" title="2、认证与授权实现思路"></a><strong>2、认证与授权实现思路</strong></h2><p>如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前请求是否有权限访问</p><p><img src="https://i0.hdslb.com/bfs/album/c93935bff79825b7b3d0c274cb8c9dfcec43cc5e.png" alt></p><h2 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h2><blockquote><p>使用场景</p></blockquote><p><img src="https://i0.hdslb.com/bfs/album/020469ba58ec19bd367c0af532083b1ae8dce523.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
            <tag> Java框架 </tag>
            
            <tag> Spring全家桶 </tag>
            
            <tag> 认证授权 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建SSR服务器</title>
      <link href="/2020/01/23/vspserver/"/>
      <url>/2020/01/23/vspserver/</url>
      
        <content type="html"><![CDATA[<h1 id="科学上网（自建SSR服务器）"><a href="#科学上网（自建SSR服务器）" class="headerlink" title="科学上网（自建SSR服务器）"></a>科学上网（自建SSR服务器）</h1><hr><blockquote><p>你还在为为翻墙难而困扰吗？你还在为 <code>git clone</code> 速度 20kb/s 而捶胸顿足吗？<strong>这个教程统统帮你解决！</strong></p></blockquote><ul><li><p>首先，自建ss/ssr很简单，分三步：</p></li><li><p>第一步：购买VPS服务器</p></li><li><p>第二步：一键部署VPS服务器</p></li><li><p>第三步：一键加速VPS服务器</p></li></ul><hr><h4 id="1-推荐-购买-vultr-服务器"><a href="#1-推荐-购买-vultr-服务器" class="headerlink" title="1.(推荐)购买 vultr 服务器"></a>1.(推荐)购买 <a href="https://my.vultr.com/" target="_blank" rel="noopener">vultr 服务器</a></h4><ul><li>VPS服务器需要选择国外的，首选国际知名的vultr，速度不错、稳定且性价比高，推荐5美元/月的服务器。</li><li>购买完成后，选择服务器位置，系统选择 centos 7 ，然后 deploy now</li><li>等待几分钟，服务器就配置完成。可以 ping IP 看是否被墙</li></ul><h4 id="2-配置VPS服务器端SSR"><a href="#2-配置VPS服务器端SSR" class="headerlink" title="2.配置VPS服务器端SSR"></a>2.配置VPS服务器端SSR</h4><ul><li>通过 <code>ssh root@yourip</code>命令登录，复制密码即可登录</li><li><code>yum -y install wget</code> 安装 wget</li><li><code>wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</code>一键部署管理脚本</li><li>根据提示选择 1 安装，然后设置端口，密码，加密方式，协议等。</li><li>最终完成部署即可</li></ul><h4 id="3-加速VSP服务器-谷歌BBR加速"><a href="#3-加速VSP服务器-谷歌BBR加速" class="headerlink" title="3.加速VSP服务器(谷歌BBR加速)"></a>3.加速VSP服务器(谷歌BBR加速)</h4><ul><li><code>wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</code>部署脚本</li><li><code>chmod +x bbr.sh</code>赋予可执行权限</li><li><code>./bbr.sh</code>运行</li><li>等待完成重启服务器即可</li></ul><hr><blockquote><p>经过上述的三步，服务器配置就完成了；使用该服务器，则用SSR客户端，输入相应的地址密码等就好了。Ubuntu 本机端SSR的安装可以参考之前的博客。</p><p>感谢大佬们的<a href="https://blog.free-air.org/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">教学</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSR </tag>
            
            <tag> VSP </tag>
            
            <tag> Server </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B l o g 配置和踩坑</title>
      <link href="/2018/09/07/myblog/"/>
      <url>/2018/09/07/myblog/</url>
      
        <content type="html"><![CDATA[<h1 id="B-l-o-g-配置和踩坑"><a href="#B-l-o-g-配置和踩坑" class="headerlink" title="B l o g 配置和踩坑"></a>B l o g 配置和踩坑</h1><hr><blockquote><p>重要的话说三遍：</p><blockquote><p>要将 blog 源代码文件上传到 github 仓库</p><blockquote><blockquote><p>要将 blog 源代码文件上传到 github 仓库</p><blockquote><blockquote><p>要将 blog 源代码文件上传到 github 仓库</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><hr><ul><li>本文主要分为两个部分：</li><li>1.新系统 blog 环境的配置 （ git NodeJS hexo npm ） </li><li><ol start="2"><li>blog 常用操作</li></ol></li><li><ol start="3"><li>blog 迁移</li></ol></li></ul><hr><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h3><ul><li>安装 Node.js <code>sudo apt install nodejs</code></li><li>安装 npm <code>sudo apt install npm</code></li><li>查看是否安装成功：<code>node -v</code> <code>npm -v</code></li><li>安装 git <code>sudo apt install git</code></li><li>安装 hexo</li></ul><blockquote><p>适的地方新建一个文件夹，用来存放自己的博客文件</p><p>输入 <code>sudo npm i hexo-cli -g</code> 安装 Hexo</p><p>输入 <code>hexo -v</code> 验证是否安装成功</p><p>初始化网站，输入 <code>hexo init</code> 初始化文件夹</p><p>输入 <code>npm install</code> 安装必备的组件</p><p>这样本地的网站配置也弄好啦，输入 <code>hexo g</code> 生成静态网页，然后输入 <code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/，就可以看到我们的博客啦" target="_blank" rel="noopener">http://localhost:4000/，就可以看到我们的博客啦</a></p></blockquote><ul><li>之后，将 blog 源代码文件拷贝到文件夹即可。</li></ul><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h3><blockquote><p>改网页时直接刷新界面即可</p></blockquote><ul><li>hexo g 生成静态网页</li><li>hexo s 本地预览效果</li><li>hexo d 上传到 github 上</li><li>hexo new post “article title” 新建一篇文章，打开_posts 目录，多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件</li><li>theme源地址（<a href="https://github.com/YenYuHsuan/hexo-theme-beantech）" target="_blank" rel="noopener">https://github.com/YenYuHsuan/hexo-theme-beantech）</a></li></ul><h3 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3.目录结构"></a>3.目录结构</h3><blockquote><p>总的来讲，站内文字部分在 blog/source/下更改，站点内容在blog/theme/matery/source。且文件结构差不多</p></blockquote><ul><li>更改音乐：/blog/source/_data/musics.json   音乐和封面存储位置：blog/public/medias/music/</li><li>友情链接：/blog/source/_data/frands,json(页面里标签方块)    文字部分：blog/source/friends/index.md</li><li>留言板（标题文字部分）/blog/source/contact/index.md</li><li>关于页面(我的简历) /blog/source/about/index.md</li><li>主页轮换的照片 /blog/theme/matery/source/medias/banner</li><li>主页右上名称 /blog/theme/matery/layout/_partial/navigation.ejs</li><li>其他深入修改，大多在 /layout 中,language 无,source 无</li></ul><h3 id="4-markdown-格式-最全"><a href="#4-markdown-格式-最全" class="headerlink" title="4. markdown 格式(最全)"></a>4. markdown 格式(最全)</h3><hr><pre><code>---title: 文章标题date: 2018-09-07 09:25:00author: Littlegagaimg: /source/images/xxx.jpgtop: true（是否置顶）cover: truecoverImg: /images/1.jpgsummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories:   - Typora  - Markdowntags:  - Typora  - Markdown---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> blog 配置 </tag>
            
            <tag> blog 写作 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
